use crate::config::{DEFAULT_PAIRED_OFFSET, DEFAULT_WRAP_CYCLING};
use crate::hyprctl::{ClientInfo, MonitorInfo};
use std::fs;
use std::path::{Path, PathBuf};

pub fn select_monitors(monitors: &[MonitorInfo]) -> Option<(String, String)> {
    if monitors.is_empty() {
        return None;
    }
    let mut sorted: Vec<&MonitorInfo> = monitors.iter().collect();
    sorted.sort_by_key(|monitor| (monitor.x, monitor.id));
    let primary = sorted[0].name.clone();
    let secondary = sorted
        .get(1)
        .map(|monitor| monitor.name.clone())
        .unwrap_or_else(|| primary.clone());
    Some((primary, secondary))
}

pub fn render_default_config() -> String {
    render_config("", "", DEFAULT_PAIRED_OFFSET, DEFAULT_WRAP_CYCLING)
}

pub fn render_config(primary: &str, secondary: &str, offset: u32, wrap_cycling: bool) -> String {
    serde_json::json!({
        "primary_monitor": primary,
        "secondary_monitor": secondary,
        "paired_offset": offset,
        "workspace_count": offset,
        "wrap_cycling": wrap_cycling,
    })
    .to_string()
}

pub fn render_bindings(bin_path: &str, workspace_count: u32) -> String {
    let mut lines = Vec::new();
    lines.push("# hyprspaces keybindings".to_string());
    for i in 1..=workspace_count {
        let code = i + 9;
        lines.push(format!(
            "bindd = SUPER, code:{code}, Paired workspace {i}, exec, {bin_path} paired switch {i}"
        ));
    }
    lines.push(format!(
        "bindd = SUPER, mouse_up, Paired prev, exec, {bin_path} paired cycle prev"
    ));
    lines.push(format!(
        "bindd = SUPER, mouse_down, Paired next, exec, {bin_path} paired cycle next"
    ));
    for i in 1..=workspace_count {
        let code = i + 9;
        lines.push(format!(
            "bindd = SUPER SHIFT, code:{code}, Move to paired {i}, exec, {bin_path} paired move-window {i}"
        ));
    }
    lines.push(String::new());
    lines.push("# Move window with arrow keys (override default swap behavior)".to_string());
    lines.push("unbind = SUPER SHIFT, LEFT".to_string());
    lines.push("unbind = SUPER SHIFT, RIGHT".to_string());
    lines.push("unbind = SUPER SHIFT, UP".to_string());
    lines.push("unbind = SUPER SHIFT, DOWN".to_string());
    lines.push("bindd = SUPER SHIFT, LEFT, Move window left, movewindow, l".to_string());
    lines.push("bindd = SUPER SHIFT, RIGHT, Move window right, movewindow, r".to_string());
    lines.push("bindd = SUPER SHIFT, UP, Move window up, movewindow, u".to_string());
    lines.push("bindd = SUPER SHIFT, DOWN, Move window down, movewindow, d".to_string());
    lines.join("\n")
}

pub fn render_autostart(bin_path: &str) -> String {
    format!("# hyprspaces autostart\nexec-once = {bin_path} daemon")
}

pub fn render_workspace_rules(primary: &str, secondary: &str, offset: u32) -> String {
    let mut lines = Vec::new();
    lines.push("# Generated by hyprspaces".to_string());
    for i in 1..=offset {
        if i == 1 {
            lines.push(format!(
                "workspace = 1, monitor:{primary}, persistent:true, default:true"
            ));
        } else {
            lines.push(format!(
                "workspace = {i}, monitor:{primary}, persistent:true"
            ));
        }
    }
    for i in 1..=offset {
        let workspace_id = i + offset;
        if i == 1 {
            lines.push(format!(
                "workspace = {workspace_id}, monitor:{secondary}, persistent:true, default:true"
            ));
        } else {
            lines.push(format!(
                "workspace = {workspace_id}, monitor:{secondary}, persistent:true"
            ));
        }
    }
    lines.join("\n")
}

pub fn render_waybar_config(bin_path: &str, theme_path: &Path) -> String {
    serde_json::json!({
        "custom/workspaces": {
            "exec": format!(
                "{bin_path} waybar --enable-waybar --theme-css {}",
                theme_path.display()
            ),
            "return-type": "json",
            "format": "{}",
            "on-scroll-up": format!("{bin_path} paired cycle prev"),
            "on-scroll-down": format!("{bin_path} paired cycle next")
        }
    })
    .to_string()
}

pub fn render_waybar_style() -> String {
    "#custom-workspaces.workspaces {\n  padding: 0 8px;\n}\n".to_string()
}

pub fn render_waybar_theme() -> String {
    "@define-color foreground #c0caf5;\n".to_string()
}

pub fn add_source_block(contents: &str, source_line: &str) -> String {
    if contents.contains(source_line) {
        return contents.to_string();
    }
    let mut output = String::from(contents);
    if !output.ends_with('\n') {
        output.push('\n');
    }
    output.push('\n');
    output.push_str("# BEGIN HYPRSPACES\n");
    output.push_str(source_line);
    output.push('\n');
    output.push_str("# END HYPRSPACES\n");
    output
}

pub fn remove_source_block(contents: &str) -> String {
    let mut output = String::new();
    let mut skipping = false;
    for line in contents.lines() {
        if line.contains("# BEGIN HYPRSPACES") {
            skipping = true;
            continue;
        }
        if line.contains("# END HYPRSPACES") {
            skipping = false;
            continue;
        }
        if !skipping {
            output.push_str(line);
            output.push('\n');
        }
    }
    output
}

pub fn migration_targets(clients: &[ClientInfo], offset: u32) -> Vec<(String, u32)> {
    clients
        .iter()
        .filter_map(|client| {
            let workspace_id = client.workspace.id;
            if workspace_id > offset && workspace_id <= offset * 2 {
                Some((client.address.clone(), workspace_id - offset))
            } else {
                None
            }
        })
        .collect()
}

#[derive(Debug, thiserror::Error)]
pub enum SetupError {
    #[error("io error: {0}")]
    Io(#[from] std::io::Error),
    #[error("missing config file: {0}")]
    MissingConfigFile(PathBuf),
}

pub fn ensure_config(
    config_path: &Path,
    monitors: Option<&[MonitorInfo]>,
) -> Result<bool, SetupError> {
    if config_path.exists() {
        return Ok(false);
    }
    let config = match monitors.and_then(select_monitors) {
        Some((primary, secondary)) => render_config(&primary, &secondary, 10, DEFAULT_WRAP_CYCLING),
        None => render_default_config(),
    };
    if let Some(parent) = config_path.parent() {
        fs::create_dir_all(parent)?;
    }
    fs::write(config_path, config)?;
    Ok(true)
}

pub fn install_waybar(base_dir: &Path, bin_path: &str) -> Result<(), SetupError> {
    let waybar_dir = base_dir.join("waybar");
    let theme_path = waybar_dir.join("theme.css");
    fs::create_dir_all(&waybar_dir)?;
    fs::write(&theme_path, render_waybar_theme())?;
    fs::write(
        waybar_dir.join("workspaces.json"),
        render_waybar_config(bin_path, &theme_path),
    )?;
    fs::write(waybar_dir.join("workspaces.css"), render_waybar_style())?;
    fs::write(waybar_dir.join("installed.flag"), "1\n")?;
    Ok(())
}

pub fn uninstall_waybar(base_dir: &Path) -> Result<bool, SetupError> {
    let waybar_dir = base_dir.join("waybar");
    let flag_path = waybar_dir.join("installed.flag");
    if !flag_path.exists() {
        return Ok(false);
    }
    for file in [
        "workspaces.json",
        "workspaces.css",
        "theme.css",
        "installed.flag",
    ] {
        let path = waybar_dir.join(file);
        if path.exists() {
            fs::remove_file(path)?;
        }
    }
    if waybar_dir.exists() {
        let _ = fs::remove_dir(waybar_dir);
    }
    Ok(true)
}

pub fn install(
    base_dir: &Path,
    bin_path: &str,
    hypr_config_dir: &Path,
    config_path: &Path,
    monitors: Option<&[MonitorInfo]>,
) -> Result<(), SetupError> {
    ensure_config(config_path, monitors)?;
    let config_data = read_config_data(config_path)?;
    fs::create_dir_all(base_dir)?;
    fs::write(
        base_dir.join("bindings.conf"),
        render_bindings(bin_path, config_data.workspace_count),
    )?;
    fs::write(base_dir.join("autostart.conf"), render_autostart(bin_path))?;
    fs::write(
        base_dir.join("workspace-rules.conf"),
        render_workspace_rules(
            &config_data.primary_monitor,
            &config_data.secondary_monitor,
            config_data.paired_offset,
        ),
    )?;

    update_source_block(
        &hypr_config_dir.join("bindings.conf"),
        &format!("source = {}", base_dir.join("bindings.conf").display()),
    )?;
    update_source_block(
        &hypr_config_dir.join("autostart.conf"),
        &format!("source = {}", base_dir.join("autostart.conf").display()),
    )?;
    update_source_block(
        &hypr_config_dir.join("hyprland.conf"),
        &format!(
            "source = {}",
            base_dir.join("workspace-rules.conf").display()
        ),
    )?;

    Ok(())
}

pub fn uninstall(base_dir: &Path, hypr_config_dir: &Path) -> Result<(), SetupError> {
    let _ = uninstall_waybar(base_dir)?;
    for file in ["bindings.conf", "autostart.conf", "hyprland.conf"] {
        let path = hypr_config_dir.join(file);
        if path.exists() {
            let updated = remove_source_block(&fs::read_to_string(&path)?);
            fs::write(path, updated)?;
        }
    }
    for file in ["bindings.conf", "autostart.conf", "workspace-rules.conf"] {
        let path = base_dir.join(file);
        if path.exists() {
            fs::remove_file(path)?;
        }
    }
    if base_dir.exists() {
        let _ = fs::remove_dir(base_dir);
    }
    Ok(())
}

#[derive(Debug)]
struct ConfigData {
    primary_monitor: String,
    secondary_monitor: String,
    paired_offset: u32,
    workspace_count: u32,
}

#[derive(Debug, serde::Deserialize)]
struct RawConfigData {
    #[serde(default)]
    primary_monitor: Option<String>,
    #[serde(default)]
    secondary_monitor: Option<String>,
    #[serde(default = "default_offset")]
    paired_offset: u32,
    #[serde(default)]
    workspace_count: Option<u32>,
}

fn default_offset() -> u32 {
    DEFAULT_PAIRED_OFFSET
}

fn read_config_data(path: &Path) -> Result<ConfigData, SetupError> {
    let contents = fs::read_to_string(path)?;
    let raw = serde_json::from_str(&contents).unwrap_or(RawConfigData {
        primary_monitor: None,
        secondary_monitor: None,
        paired_offset: DEFAULT_PAIRED_OFFSET,
        workspace_count: None,
    });
    let workspace_count = raw.workspace_count.unwrap_or(raw.paired_offset);
    Ok(ConfigData {
        primary_monitor: raw.primary_monitor.unwrap_or_default(),
        secondary_monitor: raw.secondary_monitor.unwrap_or_default(),
        paired_offset: workspace_count,
        workspace_count,
    })
}

fn update_source_block(path: &Path, source_line: &str) -> Result<(), SetupError> {
    if !path.exists() {
        return Ok(());
    }
    let updated = add_source_block(&fs::read_to_string(path)?, source_line);
    fs::write(path, updated)?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::{
        add_source_block, ensure_config, install, migration_targets, remove_source_block,
        render_autostart, render_bindings, render_config, render_default_config,
        render_workspace_rules, select_monitors, uninstall,
    };
    use crate::hyprctl::{ClientInfo, MonitorInfo, WorkspaceRef};
    use serde_json::Value;
    use std::fs;

    #[test]
    fn selects_primary_secondary_by_position() {
        let monitors = vec![
            MonitorInfo {
                name: "HDMI-A-1".to_string(),
                x: 1920,
                id: 2,
            },
            MonitorInfo {
                name: "DP-1".to_string(),
                x: 0,
                id: 1,
            },
        ];

        let selection = select_monitors(&monitors).expect("selection");

        assert_eq!(selection.0, "DP-1");
        assert_eq!(selection.1, "HDMI-A-1");
    }

    #[test]
    fn defaults_secondary_to_primary_when_single_monitor() {
        let monitors = vec![MonitorInfo {
            name: "DP-1".to_string(),
            x: 0,
            id: 1,
        }];

        let selection = select_monitors(&monitors).expect("selection");

        assert_eq!(selection.0, "DP-1");
        assert_eq!(selection.1, "DP-1");
    }

    #[test]
    fn renders_default_config_with_empty_monitors() {
        let value: Value = serde_json::from_str(&render_default_config()).expect("json");

        assert_eq!(value["primary_monitor"], "");
        assert_eq!(value["secondary_monitor"], "");
        assert_eq!(value["paired_offset"], 10);
        assert_eq!(value["workspace_count"], 10);
        assert_eq!(value["wrap_cycling"], true);
    }

    #[test]
    fn renders_config_with_monitors() {
        let value: Value =
            serde_json::from_str(&render_config("DP-1", "HDMI-A-1", 12, false)).expect("json");

        assert_eq!(value["primary_monitor"], "DP-1");
        assert_eq!(value["secondary_monitor"], "HDMI-A-1");
        assert_eq!(value["paired_offset"], 12);
        assert_eq!(value["workspace_count"], 12);
        assert_eq!(value["wrap_cycling"], false);
    }

    #[test]
    fn renders_bindings_with_bin_path() {
        let bindings = render_bindings("hyprspaces", 3);

        assert!(bindings.contains("hyprspaces paired switch 1"));
        assert!(bindings.contains("hyprspaces paired switch 3"));
        assert!(!bindings.contains("hyprspaces paired switch 4"));
        assert!(bindings.contains("hyprspaces paired cycle next"));
    }

    #[test]
    fn renders_autostart_with_bin_path() {
        let autostart = render_autostart("hyprspaces");

        assert!(autostart.contains("exec-once = hyprspaces daemon"));
    }

    #[test]
    fn renders_workspace_rules() {
        let rules = render_workspace_rules("DP-1", "HDMI-A-1", 2);

        assert!(rules.contains("workspace = 1, monitor:DP-1, persistent:true, default:true"));
        assert!(rules.contains("workspace = 2, monitor:DP-1, persistent:true"));
        assert!(rules.contains("workspace = 3, monitor:HDMI-A-1, persistent:true, default:true"));
        assert!(rules.contains("workspace = 4, monitor:HDMI-A-1, persistent:true"));
    }

    #[test]
    fn adds_source_block_once() {
        let contents = "line1\n";
        let updated = add_source_block(contents, "source = path.conf");

        assert!(updated.contains("BEGIN HYPRSPACES"));
        assert!(updated.contains("source = path.conf"));
        assert!(add_source_block(&updated, "source = path.conf").eq(&updated));
    }

    #[test]
    fn removes_source_block() {
        let contents = "line1\n# BEGIN HYPRSPACES\nsource = path.conf\n# END HYPRSPACES\nline2\n";
        let updated = remove_source_block(contents);

        assert!(!updated.contains("BEGIN HYPRSPACES"));
        assert!(updated.contains("line1"));
        assert!(updated.contains("line2"));
    }

    #[test]
    fn derives_migration_targets_for_secondary_workspaces() {
        let clients = vec![
            ClientInfo {
                address: "0x123".to_string(),
                workspace: WorkspaceRef { id: 12, name: None },
                class: None,
                title: None,
                initial_class: None,
                initial_title: None,
                app_id: None,
                pid: None,
            },
            ClientInfo {
                address: "0x456".to_string(),
                workspace: WorkspaceRef { id: 1, name: None },
                class: None,
                title: None,
                initial_class: None,
                initial_title: None,
                app_id: None,
                pid: None,
            },
        ];

        let targets = migration_targets(&clients, 10);

        assert_eq!(targets, vec![("0x123".to_string(), 2)]);
    }

    #[test]
    fn ensures_config_with_auto_detected_monitors() {
        let dir = tempfile::tempdir().expect("tempdir");
        let config_path = dir.path().join("paired.json");
        let monitors = vec![
            MonitorInfo {
                name: "DP-1".to_string(),
                x: 0,
                id: 1,
            },
            MonitorInfo {
                name: "HDMI-A-1".to_string(),
                x: 1920,
                id: 2,
            },
        ];

        let created = ensure_config(&config_path, Some(&monitors)).expect("ensure");

        assert!(created);
        let value: Value =
            serde_json::from_str(&fs::read_to_string(&config_path).expect("config read"))
                .expect("json");
        assert_eq!(value["primary_monitor"], "DP-1");
        assert_eq!(value["secondary_monitor"], "HDMI-A-1");
    }

    #[test]
    fn install_writes_fragments_and_sources() {
        let dir = tempfile::tempdir().expect("tempdir");
        let base_dir = dir.path().join("hyprspaces");
        let hypr_dir = dir.path().join("hypr");
        fs::create_dir_all(&hypr_dir).expect("hypr dir");
        fs::write(hypr_dir.join("bindings.conf"), "base\n").expect("bindings");
        fs::write(hypr_dir.join("autostart.conf"), "base\n").expect("autostart");
        fs::write(hypr_dir.join("hyprland.conf"), "base\n").expect("hyprland");
        let config_path = dir.path().join("paired.json");
        let monitors = vec![MonitorInfo {
            name: "DP-1".to_string(),
            x: 0,
            id: 1,
        }];

        install(
            &base_dir,
            "hyprspaces",
            &hypr_dir,
            &config_path,
            Some(&monitors),
        )
        .expect("install");

        assert!(base_dir.join("bindings.conf").exists());
        assert!(base_dir.join("autostart.conf").exists());
        assert!(base_dir.join("workspace-rules.conf").exists());
        let bindings = fs::read_to_string(hypr_dir.join("bindings.conf")).expect("read");
        assert!(bindings.contains("BEGIN HYPRSPACES"));
        let hyprland = fs::read_to_string(hypr_dir.join("hyprland.conf")).expect("read");
        assert!(hyprland.contains("source ="));
    }

    #[test]
    fn install_skips_missing_hypr_config_files() {
        let dir = tempfile::tempdir().expect("tempdir");
        let base_dir = dir.path().join("hyprspaces");
        let hypr_dir = dir.path().join("hypr");
        fs::create_dir_all(&hypr_dir).expect("hypr dir");
        fs::write(hypr_dir.join("hyprland.conf"), "base\n").expect("hyprland");
        let config_path = dir.path().join("paired.json");

        install(&base_dir, "hyprspaces", &hypr_dir, &config_path, None).expect("install");

        assert!(base_dir.join("bindings.conf").exists());
        assert!(base_dir.join("autostart.conf").exists());
        assert!(base_dir.join("workspace-rules.conf").exists());
        assert!(!hypr_dir.join("bindings.conf").exists());
        assert!(!hypr_dir.join("autostart.conf").exists());
        let hyprland = fs::read_to_string(hypr_dir.join("hyprland.conf")).expect("read");
        assert!(hyprland.contains("BEGIN HYPRSPACES"));
    }

    #[test]
    fn uninstall_removes_fragments_and_blocks() {
        let dir = tempfile::tempdir().expect("tempdir");
        let base_dir = dir.path().join("hyprspaces");
        fs::create_dir_all(&base_dir).expect("base dir");
        fs::write(base_dir.join("bindings.conf"), "data").expect("write");
        fs::write(base_dir.join("autostart.conf"), "data").expect("write");
        fs::write(base_dir.join("workspace-rules.conf"), "data").expect("write");
        let hypr_dir = dir.path().join("hypr");
        fs::create_dir_all(&hypr_dir).expect("hypr dir");
        let contents = "base\n# BEGIN HYPRSPACES\nsource = path\n# END HYPRSPACES\n";
        fs::write(hypr_dir.join("bindings.conf"), contents).expect("write");
        fs::write(hypr_dir.join("autostart.conf"), contents).expect("write");
        fs::write(hypr_dir.join("hyprland.conf"), contents).expect("write");

        uninstall(&base_dir, &hypr_dir).expect("uninstall");

        let bindings = fs::read_to_string(hypr_dir.join("bindings.conf")).expect("read");
        assert!(!bindings.contains("BEGIN HYPRSPACES"));
        assert!(!base_dir.join("bindings.conf").exists());
    }
}
